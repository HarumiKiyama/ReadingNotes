# -*- mode: org; coding: utf-8 -*-
#+TITLE: 计算机系统 核心概念及软硬件实现
#+STARTUP: overview
* 提出问题
- 全书讲了什么
- 全书是如何组织的
- 这本书和我有什么关系
* 书籍的简单摘要
本书基于一个简单的机器pep8,从上而下讲解了计算机的各个层级.
* 结构
** App7 层(应用层)
论述一些软件的使用,可以跳过
** HOL6 层(高级语言层)
以C++为例子论述高级语言的一些性质,具体的
*** 变量
- 论述了C++编译器执行的基本功能
- C++的内存模型
- 全局变量和赋值语句
*** 控制流
*** 函数
*** 递归
*** 动态内存分配
** ISA3 层(指令集架构层)
*** 信息的表示
描述了计算机中数据是如何保存的以及数据之间是如何进行运算的.计算机如何表示浮点数这部分内容很不错.
*** 计算机体系结构
**** 4.1和4.2
主要表述pep8的体系结构,比较详细,看的时候只要把握大概就好了.在做习题的时候会加深理解的.
**** 4.3 冯诺伊曼机器
讲述了冯诺伊曼机器的执行步骤,具体如下:
加载机器语言程序
初始化PC和SP
do{
	取下一条指令
    指令指示符解码
    递增PC
    执行取出的指令
} while (没有执行停止指令)
**** 4.4 ISA3 层编程
描述了怎么样使用机器码给 pep8 编程 可以跳过,之后在 Asmb5 层进行编程
** Asmb5 层(汇编层)
*** 汇编语言
汇编层即是对ISA3层次的抽象.隐藏了ISA3层的细节.
汇编语言的语句可以分成两种类型助记符语句(指令),伪操作(即点命令,汇编器指示字,数据)
汇编语言消除了程序中需要手工确定数据和指令地址的问题(这个是最痛苦的)
高级语言层的变量对应与汇编层的内存地址, 在汇编层唯一的类型是位,某种意义上算是完全的动态类型
*** 编译到汇编层
主要讲解C++和汇编语言之间的关系,C++的语句如何在汇编层实现
**** 栈寻址和局部变量
讲述了汇编层如何进行栈寻址的,以及数据出栈入栈的操作
要翻译程序的局部变量,编译器要:
- 用SUBSP分配内存
- 用栈相对寻址访问局部变量
- 用ADDSP释放存储
**** 转移指令和控制流
讲述了pep8的8个条件分支指令,每个条件分支检测4个状态位N,Z,V,C中的一个或者两个.
之后描述了如何用这个8个分支指令来实现C++的if语句,if/else语句,while循环,do循环,for循环
**** 函数调用和参数
C++层面的函数调用如何在汇编层面完成
- 无参空函数的调用
  以无参空函数为例子讲解了汇编层面的CALL指令和RETn指令如何配合完成函数调用的.
- 全局变量翻译传值调用参数
  具体步骤如下:
  1. 调用压入实参(执行SUBSP)
  2. 调用压入返回地址(执行CALL)
  3. 被调用分配局部变量(执行SUBSP)
  4. 被调用执行它的函数体
  5. 被调用释放局部变量,弹出返回地址(执行RETn)
  6. 调用弹出实参(执行ADDSP)
- 用局部变量翻译传值调用参数
  和全局变量不同的地方在于使用栈相对寻址的
- 翻译非空函数调用
  较前两个多了压入返回值的存储空间和释放返回值储存空间这一步.
- 用全局变量翻译传引用调用参数
  和传值调用最大的不同在于,传引用调用会把实参的地址压入栈中,然后通过栈相对间接寻址找到操作数
- 用局部变量翻译传引用调用参数
  通过把栈指针的值与局部变量的栈相对值相加,得到局部变量的绝对地址,然后同全局变量翻译
- 翻译布尔类型
  C++直到1996年都没有bool类型
**** 变址寻址和数组
- 作为全局变量的数组
  使用.BLOCK n 给数组分配储存空间,n是数组占用的总字节数
  通过把索引乘以每个单元的字节数装入变址寄存器来访问数组元素,使用变址寻址
- 作为局部变量的数组
  使用SUBSP对数组进行分配,用ADDSP释放
  通过把索引装入变址寄存器来访问数组元素,把索引乘以每个单元的字节数,使用栈变址寻址
- 作为参数传递的数组
  考虑到效率,C++中对于数组默认是传引用调用
  数组第一个元素的地址压入运行时栈,对于局部数组,使用MOVSPA后面采用立即数寻址的ADDA,
  对于全局数组,使用立即数寻址的LDA
  通过把索引装入变址寄存器来访问数组元素,将索引乘以每个单元的字节数,使用栈变址间接寻址
- 翻译switch语句
  编译器生成转移表,然后使用变址寻址的方式进行寻址
**** 动态内存分配
讲述编译器怎样翻译指针和结构(struct)
- 翻译全局指针
  用.BLOCK 2给指针分配储存空间,因为一个地址占用2字节
  在heap中分配指针指向的单元
  用直接寻址访问指针
  用间接寻址访问指针指向的单元
- 翻译局部指针
  使用SUBSP在运行时栈给指针分配储存空间,用ADDSP释放储存空间
  用栈相对寻址访问指针
  用栈相对间接寻址访问指针指向的单元
- 翻译结构
  在Asmb5层结构非常像数组,结构的字段名对应该字段距离结构第一个字节的偏移量.
  结构的每个字段等于它距离结构第一个字节的偏移量
  用.BLOCK n 给结构分配储存空间,n是结构占用的总字节数
  用立即数寻址把字段的偏移量装入变址寄存器,后面跟一条使用变址寻址方式的指令来访问结构的字段.
- 翻译链式数据结构
  结点的字段名等于字段距离节点第一个字节的偏移量,把偏移量装入变址寄存器
  访问结点字段的指令使用栈变址间接寻址的
*** 语言翻译原理
计算机科学的基本问题,什么能够被自动化,人工语言的自动化翻译是计算机科学的核心.
语言翻译可以分成词法分析,语法分析和代码生成三个步骤
计算机语言的语法是一个程序要成为合法的语言程序必须要遵守的一套规则.语法包含4个人部分:
- N, 一个非终结字符表
- T, 一个终结字符表
- P, 一套产生式规则
- S, 初始符, 为N的一个元素
词法分析即是把一串终结字符,转换为非终结字符
语法分析即是根据产生式规则校验词法分析产生的非终结字符
** OS4 层(操作系统层)
操作系统的目的是向高级语言提供一个更加方便的环境,并且有效分配系统资源(CPU时间,主存,磁盘存储器)
*** 进程管理
- 装载器
  操作系统必须把适当的程序装载到主存并把CPU的控制交给这个程序来执行
- 
*** 储存管理
** LG1 层(逻辑门层)
LG1层是一切的基础,因为考虑到成本的因素,所以会加入Mc2层来减少开发成本,但是这样速度就会变慢.
LG1层的电路有两种基本的结构,组合电路和时序电路.
组合电路即只由输入决定输出的电路,时序电路即输入确定,但是输出却可能随时间变化的电路
*** 组合电路
描述组合电路的行为有三种方式:
- 真值表 :: 列出输入值每种可能组合的输出
- 布尔代数表达式 :: 说明组合电路是怎么做的
             布尔代数表达式,具体可以看离散数学
- 逻辑图 :: 即把电路图话出来,最接近电路的一种
         
解布尔表达式卡诺图做电路优化的细节,略过
计算机设计当中普遍用到的一些电路单元,略过
*** 时序电路
相比组合电路来说是有状态的电路
时序电路也是由和组合电路一样的逻辑门组成,但是时序电路相对于组合电路来说是有反馈电路的,因为反馈电路,时序电路才有了状态
时序电路的行为通过时序图来给出图形化表示
计算机会维护一个时钟,所有设备必须根据时钟同时改变状态.
** Mc2 层(微代码层)
*** 计算机组成
介绍LG1层是如何与ISA3层联系的
Mc2 层的作用即是控制LG1层的数据流动,然后给ISA3层提供统一的接口
* 习题集
由于是绪论性质的讲得也不太深,这里只是选择性的做几题增进理解
** Chapter 5
*** 输出自己的姓名
#+BEGIN_SRC pep8
STRO name,d 
STOP
name: .ASCII "WLC\x00"
.END
#+END_SRC
*** 写出对应C++程序的汇编
#+NAME: 24题
#+BEGIN_SRC C++ 
  #include <iostream>
  using namespace std;
  int num1;
  int num2;
  int main() {
    cin >> num1 >> num2;
    cout << num2 << endl << num1 << endl;
    return 0;
  }
#+END_SRC

#+NAME: 24题
#+BEGIN_SRC pep8
DECI num1,d
DECI num2,d
DECO num2,d
CHARO '\n',i
DECO num1,d
CHARO '\n',i
STOP
num1: .BLOCK 2
num2: .BLOCK 2
.END
#+END_SRC

#+NAME 25题
#+BEGIN_SRC C++
  #include <iostream>
  using namespace std;
  const char chConst = 'a';
  char ch1;
  char ch2;
  int main() {
    cin >> ch1 >> ch2;
    cout << ch1 << chConst << ch2;
    return 0;
  }
#+END_SRC

#+NAME 25题
#+BEGIN_SRC pep8
CHARI ch1,d
CHARI ch2,d
CHARO ch1,d
CHARO chConst,i
CHARO ch2,d
STOP
chConst: .EQUATE 'a'
ch1: .BLOCK 1
ch2: .BLOCK 1
.END
#+END_SRC
*** 数值计算
#+BEGIN_SRC C++
  #include <iostream>
  using namespace std;
  int width;
  int length;
  int perim;

  int main() {
    cin >> width >> length;
    perim = (width + length) / 2;
    cout << "w = " << width << endl;
    cout << "l = " << length << endl;
    cout << endl;
    cout << "p = " << perim << endl;
    return 0;
  }
#+END_SRC

#+BEGIN_SRC pep8
DECI width,d
DECI length,d
LDA width,d
ADDA length,d
ASRA
STA perim,d
STRO w,d
DECO width,d
CHARO endl,i
STRO l,d
DECO length,d
CHARO endl,i
CHARO endl,i
STRO p,d
DECO perim,d
CHARO endl,i
STOP
width: .block 2
length: .block 2
perim: .block 2
w: .ascii "w = \x00"
l: .ascii "l = \x00"
p: .ascii "p = \x00"
endl: .equate "\n"
.END
#+END_SRC
** Chapter 6
*** 18题
将C++程序转换为pep/8程序
#+BEGIN_SRC cpp
  #include <iostream>
  using namespace std;

  int times(int mpr, int mcand) {
    if (mpr == 0) {
      return 0;
    } else if (mpr % 2 == 1) {
      return times(mpr / 2, mcand * 2) + mcand;
    } else {
      return times(mpr / 2, mcand * 2);
    }
  }

  int main() {
    int n, m;
    cin >> n >> m;
    cout << "Product: " << times(12, 12) << endl;
    return 0;
  }
#+END_SRC

#+BEGIN_SRC pep8
n:  .EQUATE 2
m:  .EQUATE 0
main: SUBSP 4,i
    DECI n,s
    DECI m,s
    STRO product,d
    LDA n,s
    STA -4,s
    LDA m,s
    STA -6,s
    SUBSP 6,i                   ;allocate mpr,mcand,retVal
    CALL times
    ADDSP 6,i
    DECO -2,s
    CHARO '\n',i
    STOP
product:    .ASCII "Product: \x00"
    ;; int times (int mpr, int mcand)
retVal: .EQUATE 6               ;retVal #2d
mpr:    .EQUATE 4               ;mpr #2d
mcand:  .EQUATE 2               ;mcand #2d
times:  LDA mpr,s               ;if (mpr==0){}
    BRNE elif                   ;
    LDA 0,i
    STA retVal,s
    RET0
elif:   LDA mpr,s               ;else if(mpr%2==1){}
    ANDA 0x0001,i
    CPA 1,i
    BRNE else
    LDA mpr,s                   ;times(mpr/2,mcand*2)
    ASRA
    STA -4,s
    LDA mcand,s
    ASLA
    STA -6,s
    SUBSP 6,i
    CALL times
    ADDSP 6,i
    LDA -2,s
    ADDA mcand,s
    STA retVal,s
    RET0
else:   LDA mpr,s                   ;times(mpr/2,mcand*2)
    ASRA
    STA -4,s
    LDA mcand,s
    ASLA
    STA -6,s
    SUBSP 6,i
    CALL times
    ADDSP 6,i
    LDA -2,s
    STA retVal,s
    RET0
.END
#+END_SRC
*** 23题
c++ 翻译到 pep8
#+BEGIN_SRC cpp
  #include <iostream>
  using namespace std;

  int binCoeff(int n, int k) {
    if ((k == 0) || (n == k)) {
      return 1;
    } else {
      return binCoeff(n - 1, k) + binCoeff(n - 1, k - 1);
    }
  }

  int main() {
    cout << binCoeff(3, 1) << "\n";
    return 0;
  }
#+END_SRC

#+RESULTS:
: 3
#+BEGIN_SRC pep8
main:   LDA 3,i
    STA -4,s
    LDA 1,i
    STA -6,s
    SUBSP 6,i
    CALL binCoeff
    ADDSP 6,i
    DECO -2,s
    CHARO '\n',i
    STOP
    ;; int binCoeff(int n,int k)
retVal: .EQUATE 6               ;retVal #2d
n:  .EQUATE 4
k:  .EQUATE 2
binCoeff:   LDA k,s
    BREQ then
    CPA n,s
    BRNE else
then:   LDA 1,i
	    STA retVal,s
	    RET0
else:   LDA n,s
    SUBA 1,i
    STA -4,s
    LDA k,s
    STA -6,s
    SUBSP 6,i
    CALL binCoeff
    ADDSP 6,i
    LDA n,s
    SUBA 1,i
    STA -6,s
    LDA k,s
    SUBA 1,i
    STA -8,s
    SUBSP 8,i
    CALL binCoeff
    ADDSP 8,i
    LDA -4,s
    ADDA -2,s
    STA retVal,s
    RET0
.END
#+END_SRC
*** 27题
C++ 翻译为 pep8
#+BEGIN_SRC cpp
  #include <iostream>
  using namespace std;
  int list[16];
  int j, numItems;
  int temp;

  int main() {
    cin >> numItems;
    temp = list[0];
    for (j = 0; j < numItems; j++) {
      cin >> list[j];
    }
    temp = list[0];
    for (j = 0; j < numItems; j++) {
      list[j] = list[j + 1];
    }
    list[numItems - 1] = temp;
    for (j = 0; j < numItems; j++) {
      cout << list[j] << ' ';
    }
    cout << endl;
    return 0;
  }
#+END_SRC

#+BEGIN_SRC pep8
main:   DECI numItems,d
    LDX 0,i
    STX j,d
for1:   CPX numItems,d
    BRGE endfor1
    ASLX
    DECI list,x
    LDX j,d
    ADDX 1,i
    STX j,d
    BR for1
endfor1:    LDX 0,i
    LDA list,x
    STA temp,d
    LDX 0,i
    STX j,d
for2:   ADDX 1,i
    CPX numItems,d
    BRGE endfor2
    ASLX
    LDA list,x
    SUBX 2,i
    STA list,x
    LDX j,d
    ADDX 1,i
    STX j,d
    BR for2
endfor2:    LDA temp,d
    LDX numItems,d
    SUBX 1,i
    ASLX
    STA list,x
    LDX 0,i
    STX j,d
for3:   CPX numItems,d
    BRGE endfor3
    ASLX
    DECO list,x
    CHARO ' ',i
    LDX j,d
    ADDX 1,i
    STX j,d
    BR for3
endfor3:    CHARO "\n",i
    STOP
list:   .BLOCK 32
j:  .BLOCK 2
numItems:   .BLOCK 2
temp:   .BLOCK 2
.END

#+END_SRC
*** 41题
这个项目考虑用Haskell来写
* 阅读的目的
理解计算机的工作原理,使自己能够写出更好的代码
考虑到是综述性质的书籍,故习题只做到第六章,第七章以及八,九章是编译原理和操作系统的部分,打算更加深入的学习,直接看编译原理和现代操作系统并且做上面的习题.第十章到第十二章只打算快速过一遍,太过底层的东西,不太感兴趣
* 吐槽
在网上下的pep8的模拟软件在archlinux上不知道为什么完全不能用,只好把源代码下载下来,自己编译了,貌似因为写的时候比较早,必须修改头文件才能通过clang++的编译.
书籍的图有很多地方都有点问题.比如pep8的结构图,看来以后还是尽量多看英文书吧.
有些地方重复的在讲,感觉废话有点多.
#+BEGIN_QUOTE
如果学生曾经接触过BASIC语言,基本上就不可能再教会他们好的编程方法了.因为作为可能的程序员,他们的智力已经受损,不可能再恢复了. --Edsger Dijkstra
#+END_QUOTE
最后几章太过偏向底层了,而且篇幅有限,每一节好像都能单独拿出来讲一学期的样子.不过因为我不关心微代码层和逻辑门层,所以只是简单的过一遍就好了.
